/****************************************************************************
 * Copyright (c) 2010 Andreas Unger and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andreas Unger - initial API and implementation 
 ****************************************************************************/

grammar org.eclipselabs.mscript.language.Mscript
hidden(WS, ML_COMMENT, SL_COMMENT)

generate ast "http://www.eclipselabs.org/mscript/AST/1.0.0"

import 'http://www.eclipse.org/emf/2002/Ecore' as ecore

Mscript :
	(packages+=PackageDefinition)*;
	
PackageDefinition :
	'package' name=QualifiedName '{'
		(elements+=PackageDefinitionElement)*
	'}';

PackageDefinitionElement :
	PackageDefinition |
	TypeDefinition |
	VariableDeclaration;
	
TypeDefinition :
	DataTypeDefinition |
	FunctionDefinition |
	CheckDefinition;

/*
 * DataTypeDefinition
 */
 
DataTypeDefinition :
	EnumerationDefinition |
	RecordDefinition |
	TypeAliasDefinition;

/*
 * Enumeration
 */
 	
EnumerationDefinition :
	'enum' name=KeywordID '{'
		(literals+=EnumerationLiteralDeclaration (',' literals+=EnumerationLiteralDeclaration)*)?
	'}';
	
EnumerationLiteralDeclaration :
	name=KeywordID;
	
/*
 * TypeDefinition
 */
 
TypeAliasDefinition :
	'type' name=KeywordID '=' type=PrimitiveTypeSpecifier ';';

/*
 * VariableDeclaration
 */

VariableDeclaration :
	(modifier=VariableModifier)? 'var' name=KeywordID (':' type=TypeSpecifier)? ('=' initialValue=Expression)? ';';

VariableModifier :
	Auto='auto' | Constant='const';
			
/*
 * Record
 */

RecordDefinition :
	'record' name=KeywordID '{'
		(fields+=RecordFieldDeclaration)*
	'}'; 

RecordFieldDeclaration :
	name=KeywordID ':' type=DataTypeSpecifier ';';

/*
 * Function
 */
 
FunctionDefinition :
	'func' name=KeywordID '(' (parameters+=ParameterDeclaration (',' parameters+=ParameterDeclaration)*)? ')' ('pre' preconditionChain=PreconditionChain)? body=Block;

CheckDefinition :
	'check' name=KeywordID '(' (parameters+=ParameterDeclaration (',' parameters+=ParameterDeclaration)*)? ')' ('pre' preconditionChain=PreconditionChain)? body=Block;

ParameterDeclaration :
	(reference?='ref')? name=KeywordID ':' type=TypeSpecifier;

PreconditionChain :
	preconditions+=FeatureCall (',' preconditions+=FeatureCall)*;
	
/*
 * Statement
 */

Statement :
	Block |
	FeatureCallStatement |
	IfStatement |
	WhileStatement |
	DoWhileStatement |
	ForeachStatement |
	TypeDefinition |
	VariableDeclaration |
	ReturnStatement |
	CheckStatusStatement;
		
Block :
	{Block} '{' (statements+=Statement)* '}';

FeatureCallStatement :
	featureCall=FeatureCall ('=' assignedValue=Expression)? ';';

IfStatement :
	'if' cases+=IfCase ('elseif' cases+=IfCase)* ('else' elseBody=Block)?;

IfCase :
	condition=Expression body=Block;
	
WhileStatement :
	'while' predicate=Expression body=Block;
	
DoWhileStatement :
	'do' body=Block 'while' predicate=Expression ';';

ForeachStatement :
	'foreach' elementName=KeywordID 'in' collectionExpression=Expression body=Block;
	
ReturnStatement :
	{ReturnStatement} 'return' (value=Expression)? ';';
	
CheckStatusStatement :
	kind=CheckStatusKind message=Expression ';';
	
enum CheckStatusKind :
	Info='info' |
	Warning='warning' |
	Error='error' |
	Fatal='fatal';

/*
 * Data type specifier
 */

TypeSpecifier :
	DataTypeSpecifier | UnitTypeSpecifier;
	
DataTypeSpecifier :
	PrimitiveTypeSpecifier | NamedTypeSpecifier;
	
PrimitiveTypeSpecifier :
	NumericalTypeSpecifier | BooleanTypeSpecifier | StringTypeSpecifier;
	
NumericalTypeSpecifier :
	RealTypeSpecifier | IntegerTypeSpecifier | ComplexTypeSpecifier | GaussianTypeSpecifier;
	
RealTypeSpecifier :
	{RealTypeSpecifier} 'real' ('(' unit=UnitExpression ')')? ('[' dimensions+=ArrayDimensionSpecification (',' dimensions+=ArrayDimensionSpecification)* ']')?;
	
IntegerTypeSpecifier :
	{IntegerTypeSpecifier} 'int' ('(' unit=UnitExpression ')')? ('[' dimensions+=ArrayDimensionSpecification (',' dimensions+=ArrayDimensionSpecification)* ']')?;
	
ComplexTypeSpecifier :
	{ComplexTypeSpecifier} 'complex' ('(' unit=UnitExpression ')')? ('[' dimensions+=ArrayDimensionSpecification (',' dimensions+=ArrayDimensionSpecification)* ']')?;

GaussianTypeSpecifier :
	{GaussianTypeSpecifier} 'gauss' ('(' unit=UnitExpression ')')? ('[' dimensions+=ArrayDimensionSpecification (',' dimensions+=ArrayDimensionSpecification)* ']')?;

BooleanTypeSpecifier :
	{BooleanTypeSpecifier} 'bool' ('[' dimensions+=ArrayDimensionSpecification (',' dimensions+=ArrayDimensionSpecification)* ']')?;
	
StringTypeSpecifier :
	{StringTypeSpecifier} 'string' ('[' dimensions+=ArrayDimensionSpecification (',' dimensions+=ArrayDimensionSpecification)* ']')?;
	
NamedTypeSpecifier :
	typeReference=SymbolReference ('[' dimensions+=ArrayDimensionSpecification (',' dimensions+=ArrayDimensionSpecification)* ']')?;
	
ArrayDimensionSpecification :
	unspecified?='?' | size=Expression ({ArrayDimensionSpecification.beginIndex=current} '..' endIndex=Expression)?;
	
UnitTypeSpecifier :
	{UnitTypeSpecifier} 'unit';

/*
 * Expressions
 */
	
Expression :
	ConditionalExpression | RangeExpression;

ConditionalExpression :
	'if' cases+=ConditionalExpressionCase ('elseif' cases+=ConditionalExpressionCase)* 'else' elseExpression=Expression;
	
ConditionalExpressionCase:
	conditionExpression=Expression 'then' thenExpression=Expression;

RangeExpression returns Expression :
	LogicalOrExpression ({RangeExpression.begin=current} ':' end=LogicalOrExpression ({RangeExpression.increment=current} ':' end=LogicalOrExpression)?)?;

LogicalOrExpression returns Expression :
	LogicalAndExpression ({LogicalOrExpression.operands+=current} ('or' operands+=LogicalAndExpression)+)?;
	
LogicalAndExpression returns Expression :
	LogicalNotExpression ({LogicalAndExpression.operands+=current} ('and' operands+=LogicalNotExpression)+)?;

LogicalNotExpression returns Expression :
	RelationalExpression | {LogicalNotExpression} 'not' operand=RelationalExpression;

RelationalExpression returns Expression :
	AddSubtractExpression ({RelationalExpression.leftOperand=current} (typeTest?='is' type=DataTypeSpecifier | operator=RelationalOperator rightOperand=AddSubtractExpression))?;

enum RelationalOperator :
	LessThan='<' |
	LessThanOrEqualTo='<=' |
	GreaterThan='>' |
	GreaterThanOrEqualTo='>=' |
	EqualTo='==' |
	NotEqualTo='!=';

AddSubtractExpression returns Expression :
	MultiplyDivideExpression ({AddSubtractExpression.leftOperand=current} (rightParts+=AddSubtractExpressionPart)+)?;

AddSubtractExpressionPart :
	operator=AddSubtractOperator operand=MultiplyDivideExpression;

enum AddSubtractOperator :
	Add='+' |
	Subtract='-';

MultiplyDivideExpression returns Expression :
	PowerExpression ({MultiplyDivideExpression.leftOperand=current} (rightParts+=MultiplyDivideExpressionPart)+)?;

MultiplyDivideExpressionPart :
	operator=MultiplyDivideOperator operand=PowerExpression;
	
enum MultiplyDivideOperator :
	Multiply='*' |
	Divide='/' |
	ElementWiseMultiply='.*' |
	ElementWiseDivide='./';
	
PowerExpression returns Expression :
	UnaryMinusExpression ({PowerExpression.operand=current} operator=PowerOperator exponent=UnaryMinusExpression)?;

enum PowerOperator :
	Power='^' |
	ElementWisePower='.^';
	
UnaryMinusExpression returns Expression :
	FeatureCall | {UnaryMinusExpression} '-' operand=FeatureCall;

FeatureCall returns Expression :
	PrimaryExpression | CallablePrimaryExpression ({FeatureCall.target=current} (parts+=FeatureCallPart)+)?;

FeatureCallPart :
	FeatureReference | ArrayElementReference | OperationCall;
	
FeatureReference :
	'.' featureName=(ID | 'unit');
	
ArrayElementReference :
	'[' subscripts+=Subscript (',' subscripts+=Subscript)* ']';

OperationCall :
	{OperationCall} '(' (arguments+=Expression (',' arguments+=Expression)*)? ')';

CallablePrimaryExpression returns Expression :
	MatrixConstructionOperator |
	SymbolReference |
	ParenthesizedExpression;

PrimaryExpression returns Expression :
	Literal |
	UnitConstructionOperator |
	BeginExpression |
	EndExpression;

Literal :
	NumericalLiteral | BooleanLiteral | StringLiteral;
	
NumericalLiteral :
	RealLiteral | IntegerLiteral;
	
RealLiteral :
	value=REAL (imaginary?='j')? ('(' unit=UnitExpression ')')?;
	
IntegerLiteral :
	value=INTEGER (imaginary?='j')? ('(' unit=UnitExpression ')')?;

BooleanLiteral :
	value=BooleanKind;

enum BooleanKind :
	False='false' | True='true';
	
StringLiteral :
	value=STRING;
	
QualifiedName :
	identifiers+=KeywordID ('::' identifiers+=KeywordID)*;

SymbolReference :
	(global?='::')? name=QualifiedName;
	
Subscript :
	all?=':' | expression=Expression;

MatrixConstructionOperator :
	'[' expressionLists+=ExpressionList (';' expressionLists+=ExpressionList)* ']';
	
ExpressionList :
	expressions+=Expression (',' expressions+=Expression)*;
	
UnitConstructionOperator :
	'unit' '(' unitExpression=UnitExpression ')';

ParenthesizedExpression :
	'(' expression=Expression ')';

BeginExpression :
	{BeginExpression} 'begin';

EndExpression :
	{EndExpression} 'end';
	
/*
 * Unit expressions
 */
	
UnitExpression :
	unspecified?='?' | 'eval' expression=Expression  | numerator=UnitExpressionNumerator ('/' denominator=UnitExpressionDenominator)?;

UnitExpressionNumerator :
	one=INTEGER /* must be '1' */ | factors+=UnitExpressionFactor ('*' factors+=UnitExpressionFactor)*;

UnitExpressionDenominator :
	factors+=UnitExpressionFactor | '(' factors+=UnitExpressionFactor ('*' factors+=UnitExpressionFactor)* ')';

UnitExpressionFactor :
	operand=KeywordID ('^' exponent=UnitExpressionExponent)?;

UnitExpressionExponent :
	(negative?='-')? value=INTEGER;

/*
 * Keyword ID
 */
	
KeywordID :
	ID | 'j';

/*
 * Terminals
 */
 
terminal ID :
	('_' | 'a'..'z' | 'A'..'Z') ('0'..'9' | '_' | 'a'..'z' | 'A'..'Z')*;

terminal STRING : 
	'"' (!('\\' | '"') | '\\' ("'" | '"' | '?' | '\\' | 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v'))* '"';

terminal REAL returns ecore::EDouble :
	('0'..'9')+ '.' ('0'..'9')* (('e' | 'E') ('+'|'-')? ('0'..'9')+)?;

terminal INTEGER returns ecore::ELong :
	('0'..'9')+;

terminal ML_COMMENT :
	'/*' -> '*/';

terminal SL_COMMENT :
	'//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS :
	(' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER :
	.;
