«IMPORT blockdiagram»
«IMPORT org::esmp::dsm::codegen::c»

«EXTENSION org::esmp::dsm::codegen::c::extensions::Block»

«DEFINE main(CCodegenContext ctx) FOR Block»
	«EXPAND headerFile(ctx)»
«ENDDEFINE»

«DEFINE headerFile(CCodegenContext ctx) FOR Block»
	«FILE theHeaderFile(ctx) HEADER-»
		#ifndef «theHeaderMacro(ctx)»
		#define «theHeaderMacro(ctx)»
		
		#include <stdint.h>
		
		«IF getParameterValue("Delay").asInteger() == 1-»
			«EXPAND unitDelay(ctx)-»
		«ELSE-»
			«EXPAND multiDelay(ctx)-»
		«ENDIF-»
		
		#endif /* «theHeaderMacro(ctx)» */
	«ENDFILE»
«ENDDEFINE»

«DEFINE unitDelay(CCodegenContext ctx) FOR Block-»
	#define «theInstanceDeclarationsMacro(ctx)» \
		static «theCDataType(ctx)» «theVariablePrefix(ctx)»previousValue;
	
	#define «theInitializeFunction(ctx)»() \
		«theVariablePrefix(ctx)»previousValue = «theParameterValue(ctx, "InitialCondition")»

	#define «theLocalDeclarationsMacro(ctx)» \
		«theCDataType(ctx)» «theVariablePrefix(ctx)»inputValue = «getBlockDataType().theValue(0)»;
	
	«LET inputs.first().ports.first() AS inputPort-»
		#define «inputPort.theConsumeInputValueFunction(ctx)»(value) \
			«theVariablePrefix(ctx)»inputValue = (value)
	«ENDLET-»
	
	#define «theComputeOutputValuesFunction(ctx)»()

	«LET outputs.first().ports.first() AS outputPort-»
		#define «outputPort.theGetOutputValueFunction(ctx)»() \
			«theVariablePrefix(ctx)»previousValue
	«ENDLET-»
		
	#define «theUpdateFunction(ctx)»() \
		«theVariablePrefix(ctx)»previousValue = «theVariablePrefix(ctx)»inputValue
«ENDDEFINE»

«DEFINE multiDelay(CCodegenContext ctx) FOR Block-»
	#include <esmp/queue.h>

	#define «theInstanceDeclarationsMacro(ctx)» \
		static ESMP_QUEUE(«theTypePrefix(ctx)»InputQueue, «theCDataType(ctx)», «getParameterValue("Delay").asInteger() + 1») «theVariablePrefix(ctx)»inputQueue;
	
	#define «theInitializeFunction(ctx)»() \
		do { \
			int i; \
			for (i = 0; i < «getParameterValue("Delay").asInteger()»; ++i) { \
				ESMP_QUEUE_ADD(«theVariablePrefix(ctx)»inputQueue, «theParameterValue(ctx, "InitialCondition")»); \
			} \
		} while (0)

	«LET inputs.first().ports.first() AS inputPort-»
		#define «inputPort.theConsumeInputValueFunction(ctx)»(value) \
			ESMP_QUEUE_ADD(«theVariablePrefix(ctx)»inputQueue, (value))
	«ENDLET-»
	
	#define «theComputeOutputValuesFunction(ctx)»()

	«LET outputs.first().ports.first() AS outputPort-»
		#define «outputPort.theGetOutputValueFunction(ctx)»() \
			ESMP_QUEUE_FRONT(«theVariablePrefix(ctx)»inputQueue)
	«ENDLET-»
		
	#define «theUpdateFunction(ctx)»() \
		ESMP_QUEUE_REMOVE(«theVariablePrefix(ctx)»inputQueue)
«ENDDEFINE»
