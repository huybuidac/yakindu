«IMPORT executiongraph»
«IMPORT org::esmp::dsm::codegen::c»
«IMPORT org::esmp::dsm::expressions»

«EXTENSION org::esmp::dsm::codegen::c::extensions::Block»

«DEFINE main(CCodegenContext ctx) FOR ExecutionGraph»
	«EXPAND headerFile(ctx)»
	«EXPAND sourceFile(ctx)»
«ENDDEFINE»

«DEFINE headerFile(CCodegenContext ctx) FOR ExecutionGraph»
	«FILE blockDiagram.theHeaderFile(ctx) HEADER-»
	#ifndef «blockDiagram.theHeaderMacro(ctx)»
	#define «blockDiagram.theHeaderMacro(ctx)»
	
	#include <stdint.h>

	typedef struct _«blockDiagram.theInputStruct(ctx)» {
	«EXPAND inputMembers(ctx) FOREACH nodes-»
	} «blockDiagram.theInputStruct(ctx)»;

	typedef struct _«blockDiagram.theOutputStruct(ctx)» {
	«EXPAND outputMembers(ctx) FOREACH nodes-»
	} «blockDiagram.theOutputStruct(ctx)»;
	
	void «blockDiagram.theInitializeFunction(ctx)»(void);
	void «blockDiagram.theExecuteFunction(ctx)»(const «blockDiagram.theInputStruct(ctx)» *input, «blockDiagram.theOutputStruct(ctx)» *output);
	
	#endif /* «blockDiagram.theHeaderMacro(ctx)» */
	«ENDFILE»
«ENDDEFINE»

«DEFINE inputMembers(CCodegenContext ctx) FOR ExecutionNode-»
	«IF block.isInport()-»
		«block.theCDataType(ctx)» «block.theInputStructMember(ctx)»;
	«ENDIF-»
«ENDDEFINE»

«DEFINE outputMembers(CCodegenContext ctx) FOR ExecutionNode-»
	«IF block.isOutport()-»
		«block.theCDataType(ctx)» «block.theOutputStructMember(ctx)»;
	«ENDIF-»
«ENDDEFINE»

«DEFINE sourceFile(CCodegenContext ctx) FOR ExecutionGraph»
	«FILE blockDiagram.theSourceFile(ctx) SOURCE-»
	#include "«blockDiagram.theHeaderFile(ctx)»"
	«FOREACH nodes AS node-»
		«IF node.block.isConcrete()-»
			#include "«node.block.theHeaderFile(ctx)»"
		«ENDIF-»
	«ENDFOREACH-»

	«FOREACH nodes AS node-»
		«IF node.block.isConcrete()-»
			#ifdef «node.block.theInstanceDeclarationsMacro(ctx)»
			«node.block.theInstanceDeclarationsMacro(ctx)»
			#endif /* «node.block.theInstanceDeclarationsMacro(ctx)» */
		«ENDIF-»
	«ENDFOREACH-»
	
	void «blockDiagram.theInitializeFunction(ctx)»(void) {
		«EXPAND initializeBlock(ctx) FOREACH nodes»
	}
	
	void «blockDiagram.theExecuteFunction(ctx)»(const «blockDiagram.theInputStruct(ctx)» *input, «blockDiagram.theOutputStruct(ctx)» *output) {
		«FOREACH nodes AS node-»
			«IF node.block.isConcrete()-»
				#ifdef «node.block.theLocalDeclarationsMacro(ctx)»
				«node.block.theLocalDeclarationsMacro(ctx)»
				#endif /* «node.block.theLocalDeclarationsMacro(ctx)» */
			«ENDIF-»
		«ENDFOREACH-»
				
		«FOREACH nodes AS node-»
			«IF node.block.isConcrete()-»
				#ifdef «node.block.theLocalInitializationsMacro(ctx)»
				«node.block.theLocalInitializationsMacro(ctx)»
				#endif /* «node.block.theLocalInitializationsMacro(ctx)» */
			«ENDIF-»
		«ENDFOREACH-»
		«EXPAND executeBlock(ctx) FOREACH nodes»
		«EXPAND updateBlock(ctx) FOREACH nodes»
	}
	«ENDFILE»
«ENDDEFINE»

«DEFINE initializeBlock(CCodegenContext ctx) FOR ExecutionNode-»
	«IF block.isConcrete()-»
		«block.theInitializeFunction(ctx)»();
	«ENDIF-»
«ENDDEFINE»

«DEFINE executeBlock(CCodegenContext ctx) FOR ExecutionNode-»
	«IF block.isInport()»
		«LET block.outputPorts.first() AS outputPort-»
			«FOREACH outputPort.outgoingConnections AS connection-»
				«IF connection.targetPort.block.isConcrete()-»
					«connection.targetPort.theConsumeInputValueFunction(ctx)»(input->«block.theInputStructMember(ctx)»);
				«ENDIF-»
			«ENDFOREACH-»
		«ENDLET-»
	«ELSEIF block.isConcrete()»
		{
		«block.theCDataType(ctx)» value;
		«block.theComputeOutputValuesFunction(ctx)»();
		«FOREACH block.outputPorts AS outputPort-»
			value = «outputPort.theGetOutputValueFunction(ctx)»();
			«FOREACH outputPort.outgoingConnections AS connection-»
				«IF connection.targetPort.block.isOutport()-»
					output->«connection.targetPort.block.theOutputStructMember(ctx)» = value;
				«ELSEIF connection.targetPort.block.isConcrete()-»
					«connection.targetPort.theConsumeInputValueFunction(ctx)»(value);
				«ENDIF-»
			«ENDFOREACH-»
		«ENDFOREACH-»
		}
	«ENDIF-»
«ENDDEFINE»

«DEFINE updateBlock(CCodegenContext ctx) FOR ExecutionNode-»
	«IF block.isConcrete()-»
		«block.theUpdateFunction(ctx)»();
	«ENDIF-»
«ENDDEFINE»